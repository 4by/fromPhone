1,2)
Процесс это то, что предоставляет ресурсы, необходимые для выполнения программы.

Поток это абстракция уровня операционной системы, содержащая
отдельный контекст (стек) выполнения, позволяющая выполнять несколько задач
одновременно или переключаться между ними. Является объектом процесса

Процессы в отличие от потока действительно могут выполняться параллельно,
так как они распределяются между ядрами процессора.
Также у разных процессов разная область памяти, в отличие от потоков

3)
Многопроцессорность - это использование двух или более процессорных блоков в одной компьютерной системе.
Многопоточность - это способность ЦП разделять один процесс на несколько логических потоков, которые работают псевдо-параллельно
Основное отличие состоит в том, что разделение на потоки происходит внутри одного процесса, не переключаясь между ядрами ЦП.
Также в том, что в многопроцессорности разная область памяти

4)
При создании потока, мы передаём в качестве параметра имя функции, исполняемую в потоке, а также
параметры, которые будут переданы этой функции

5)
Работа распределяется на N процессов, разветвлённых с помощью API модуля multiprocessing
Варианты работы с процессами с применением API модуля multiprocessing это, например, классы 
Pool, Process

6)
Процесс-демон это поток, работающий "в фоне" и завершение которого не мешает остановке программы
Python-приложение не будет закрыто до тех пор, пока в нем работает хотя бы один недемонический процесс.

7) 
GIL – это механизм блокировки, когда интерпретатор Python 
запускает в работу только один поток за раз

8)
• Одновременно может выполняться один поток.
• Интерпретатор Python переключается между потоками для достижения 
конкурентности.
• GIL делает однопоточные программы быстрыми.
• Операциям ввода/вывода GIL обычно не мешает.
• GIL позволяет легко интегрировать непотокобезопасные библиотеки на C, 
благодаря GIL у нас есть много высокопроизводительных 
расширений/модулей, написанных на C.
• Для CPU зависимых задач интерпретатор делает проверку каждые N тиков и 
переключает потоки. Таким образом один поток не блокирует другие.

9)
Потоки в Python лучше всего работают с операциями 
Input/Output (IO), такими как загрузка ресурсов из интернета или чтение файлов и папок 
на компьютере. Это связано с тем, что IO операции (чтение/запись файла, чтение 
из сокета), запущенные интерпретатором Python, выполняются операционной системой. 
В это время интерпретатор Python может продолжать исполнять код в другом потоке, 
пока IO операция, выполняемая операционной системой, не завершится

10)
Если нужно работать с трудоёмкими операциями на CPU (например: циклы, 
обрабатывающие большое количество объектов, парсинг сложных форматов, сложные 
математические вычисления), тогда нужно обратить внимание на модуль 
multiprocessing вместо threading. Причина заключается в том, что Python содержит 
Global Interpreter Lock (GIL).

11)
Когда у нас нет непосредственного взаимодействия с файловой системой ОС или обращений к 
CPU, требующих параллелизма

12)
Когда нам необходимо, чтобы изменение в функции потока было атомарным

13)
Весь код внутри заблокированного блока будет выполнятся только в одном потоке.
Другими словами, если два разных потока вызовут заблокированный участок,etо пока 
первый поток не выйдет из блока второй будет его ждать – и только потом продолжит выполнение.

14)
Так как любые блокировки замедляют выполнение программы - лучше избегать использование блокировок 
и отдавать предпочтение обмену данными через очереди. Они распределяют глобальный ресурс между потоками

15)
Порой не желательно иметь столько же потоков, сколько задач у нас имеется для обработки. Скажем, у вас имеется большое число подлежащих обработки, тогда было бы достаточно не эффективно порождать то же самое число
потоков и иметь каждый поток исполняющим только одну задачу. Может дать больше преимуществ наличие фиксированного числа потоков (обычно именуемого неким пулом потоков), который мог бы работать с имеющимися задачами на основе кооперации.
Здесь на сцену выходит понятие очереди. У нас есть возможность спроектировать некую структуру, в которой наш пул потоков не будет сохранять какую бы то ни было информацию относящуюся к задачам, которые ему следует исполнять, а вместо этого 
сами задачи хранятся в некоторой очереди (иными словами, создают очередь задач), и соответствующие элементы из этой очереди будут питать персональных участников имеющегося пула потоков. По мере того как выбранная задача завершается неким участником
нашего пула потоков, если присутствующая очередь задач всё ещё содержит подлежащие обработке элементы, тогда следующий элемент из этой очереди будет отправлен в тот поток, который только что освободился.

16)
В обычной очереди все элементы обрабатываются в том порядке, в котором они были добавлены в эту очередь; иными словами, самый первый добавленный в очередь элемент покидает эту очередь первым (FIFO).
В отличии от обычной очереди, принцип выборки из очереди с приоритетами полагается на значение приоритета имеющихся элементов: те элементы, у которых приоритет выше, обрабатываются ранее конкурентов с меньшим приоритетом.
